// SPDX-FileCopyrightText: 2023 Marshall Wace <opensource@mwam.com>
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileContributor: Tim Kendrick <t.kendrick@mwam.com> https://github.com/timkendrickmw
// SPDX-FileContributor: Chris Campbell <c.campbell@mwam.com> https://github.com/c-campbell-mwam
// SPDX-FileContributor: Jordan Hall <j.hall@mwam.com> https://github.com/j-hall-mwam
use std::{
    fs,
    iter::{empty, once},
    net::SocketAddr,
    path::{Path, PathBuf},
    str::FromStr,
    time::Duration,
};

use anyhow::{anyhow, Context, Result};
use clap::Parser;
use futures::{Future, FutureExt};
use metrics_exporter_prometheus::PrometheusBuilder;
use opentelemetry::trace::noop::NoopTracer;
use reflex::core::{ArgType, Expression};
use reflex_dispatcher::{Action, HandlerContext, TaskFactory};
use reflex_engine::task::wasm_worker::WasmHeapDumpMode;
use reflex_graphql::{parse_graphql_schema, GraphQlSchema, NoopGraphQlQueryTransform};
use reflex_grpc::{
    actor::{GrpcHandler, GrpcHandlerMetricNames},
    load_grpc_services, DefaultGrpcConfig,
};
use reflex_handlers::{
    default_handler_actors,
    utils::tls::{create_https_client, hyper_rustls},
    DefaultHandlerMetricNames,
};
use reflex_lang::{allocator::DefaultAllocator, CachedSharedTerm, SharedTermFactory};
use reflex_parser::{syntax::js::default_js_loaders, Syntax};
use reflex_protobuf::types::WellKnownTypesTranscoder;
use reflex_recorder::{
    effect::{EffectEventSerializerEventSink, EffectRecorder, SerializedEffectEvent},
    file_recorder::FileRecorder,
    session_recorder::SessionRecorder,
};
use reflex_runtime::actor::evaluate_handler::EvaluateHandlerAction;
use reflex_scheduler::threadpool::TokioRuntimeThreadPoolFactory;
use reflex_server::{
    action::ServerCliAction,
    builtins::ServerBuiltins,
    cli::{
        reflex_server::{
            cli, GraphQlWebServerMetricLabels, OpenTelemetryConfig, ReflexServerCliOptions,
        },
        task::{ServerCliTaskActor, ServerCliTaskFactory},
    },
    generate_session_recording_filename,
    logger::{
        async_channel::AsyncChannelEventSink, formatted::FormattedActionLogger,
        formatter::TimestampedLogFormatter, json::JsonActionLogger,
        messages::DefaultActionFormatter, prometheus::PrometheusLogger, ActionLogger, ChainLogger,
        EitherLogger, SharedLogger,
    },
    scheduler_metrics::{
        NoopServerMetricsSchedulerQueueInstrumentation, ServerMetricsInstrumentation,
        ServerSchedulerMetricNames,
    },
    server::{
        action::init::{
            InitHttpServerAction, InitOpenTelemetryAction, InitPrometheusMetricsAction,
            InitSessionRecordingAction,
        },
        utils::EitherTracer,
    },
    tokio_runtime_metrics_export::TokioRuntimeMonitorMetricNames,
    GraphQlWebServerActorFactory, GraphQlWebServerMetricNames,
};
use reflex_utils::{reconnect::FibonacciReconnectTimeout, FileWriterFormat};
use reflex_wasm::{
    cli::compile::{
        parse_and_compile_module, CompilerRootConfig, GraphRootEntryPoint,
        JavaScriptCompilerRootConfig, JsonCompilerRootConfig, LispCompilerRootConfig,
        ModuleEntryPoint, RuntimeEntryPointSyntax, WasmCompilerOptions, WasmCompilerRuntimeOptions,
    },
    compiler::CompilerOptions,
    interpreter::WasmProgram,
};
use serde::Serialize;

const RUNTIME_BYTES: &'static [u8] = include_bytes!("../../../reflex-wasm/build/runtime.wasm");

/// Launch a GraphQL server for the provided graph root
#[derive(Parser)]
struct Args {
    /// Path to graph definition entry point
    input_path: PathBuf,
    /// Graph definition syntax (defaults to inferring based on graph definition file extension)
    #[clap(long)]
    syntax: Option<RuntimeEntryPointSyntax>,
    /// Name of graph root entry point function within WebAssembly module (only valid for WASM entry points)
    #[clap(long)]
    entry_point: Option<ModuleEntryPoint>,
    /// Path to GraphQL schema SDL
    #[clap(long)]
    schema: Option<PathBuf>,
    /// Port on which to expose a GraphQL HTTP server
    #[clap(long)]
    port: u16,
    /// Port on which to expose Prometheus HTTP metrics
    #[clap(long)]
    metrics_port: Option<u16>,
    /// Paths of compiled gRPC service definition protobufs
    #[clap(long)]
    grpc_service: Vec<PathBuf>,
    /// Throttle stateful effect updates
    #[clap(long)]
    effect_throttle_ms: Option<u64>,
    /// Log runtime actions
    #[clap(long)]
    log: Option<Option<LogFormat>>,
    /// Path to capture runtime event playback file (defaults to an autogenerated filename)
    #[clap(long)]
    capture_events: Option<Option<PathBuf>>,
    /// If capturing a runtime event playback file, filter events to only capture a certain category of events (valid options are "effect", defaulting to all events)
    #[clap(long)]
    capture_type: Option<EventCaptureType>,
    /// Skip compiler optimizations
    #[clap(long)]
    unoptimized: bool,
    /// Compile array items as lazily-evaluated expressions
    #[clap(long)]
    lazy_list_items: bool,
    /// Compile record field values as lazily-evaluated expressions
    #[clap(long)]
    lazy_record_values: bool,
    /// Compile function call arguments as lazily-evaluated expressions
    #[clap(long)]
    lazy_function_args: bool,
    /// Compile variable initializer values as lazily-evaluated expressions
    #[clap(long)]
    lazy_variable_initializers: bool,
    /// Compile lambda arguments as lazily-evaluated expressions
    #[clap(long)]
    lazy_lambda_args: bool,
    /// Compile constructor arguments as lazily-evaluated expressions
    #[clap(long)]
    lazy_constructors: bool,
    /// Wrap compiled lambdas in argument memoization wrappers
    #[clap(long)]
    memoize_lambdas: bool,
    /// Dump heap snapshots for any queries that return error results
    #[clap(long)]
    dump_heap_snapshot: Option<WasmHeapDumpMode>,
}
impl Into<ReflexServerCliOptions> for Args {
    fn into(self) -> ReflexServerCliOptions {
        ReflexServerCliOptions {
            address: SocketAddr::from(([0, 0, 0, 0], self.port)),
        }
    }
}

#[derive(Clone, Copy, Debug)]
enum LogFormat {
    Json,
}
impl FromStr for LogFormat {
    type Err = anyhow::Error;
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input.to_lowercase().as_str() {
            "json" => Ok(Self::Json),
            _ => Err(anyhow!("Unrecognized log format: {}", input)),
        }
    }
}

#[derive(PartialEq, Eq, Clone, Copy, Debug)]
enum EventCaptureType {
    Effect,
}
impl FromStr for EventCaptureType {
    type Err = anyhow::Error;
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input.to_lowercase().as_str() {
            "effect" | "effects" => Ok(Self::Effect),
            _ => Err(anyhow!("Unrecognized event capture type: {}", input)),
        }
    }
}

#[tokio::main]
pub async fn main() -> Result<()> {
    type TBuiltin = ServerBuiltins;
    type T = CachedSharedTerm<TBuiltin>;
    type TFactory = SharedTermFactory<TBuiltin>;
    type TAllocator = DefaultAllocator<T>;
    type TConnect = hyper_rustls::HttpsConnector<hyper::client::HttpConnector>;
    type TReconnect = FibonacciReconnectTimeout;
    type TGrpcConfig = DefaultGrpcConfig;
    type TAction = ServerCliAction<T>;
    type TTask = ServerCliTaskFactory<
        T,
        TFactory,
        TAllocator,
        TConnect,
        TReconnect,
        TGrpcConfig,
        NoopGraphQlQueryTransform,
        NoopGraphQlQueryTransform,
        GraphQlWebServerMetricLabels,
        GraphQlWebServerMetricLabels,
        GraphQlWebServerMetricLabels,
        GraphQlWebServerMetricLabels,
        GraphQlWebServerMetricLabels,
        EitherTracer<NoopTracer, opentelemetry::sdk::trace::Tracer>,
    >;

    let args = Args::parse();
    let input_path = &args.input_path;
    let factory: TFactory = SharedTermFactory::<TBuiltin>::default();
    let allocator: TAllocator = DefaultAllocator::default();
    let syntax = match args.syntax {
        Some(syntax) => Ok(syntax),
        None => {
            let file_extension = input_path
                .extension()
                .ok_or_else(|| anyhow!("Unable to determine entry point filename extension"))?;
            RuntimeEntryPointSyntax::infer(file_extension)
                .ok_or_else(|| anyhow!("Unable to infer entry point syntax based on filename"))
        }
    }?;
    let compiler_options = {
        let defaults = WasmCompilerOptions::default();
        WasmCompilerOptions {
            compiler: {
                let defaults = CompilerOptions::default();
                CompilerOptions {
                    lazy_record_values: match args.lazy_record_values {
                        true => ArgType::Lazy,
                        false => defaults.lazy_record_values,
                    },
                    lazy_list_items: match args.lazy_list_items {
                        true => ArgType::Lazy,
                        false => defaults.lazy_list_items,
                    },
                    lazy_variable_initializers: match args.lazy_variable_initializers {
                        true => ArgType::Lazy,
                        false => defaults.lazy_variable_initializers,
                    },
                    lazy_function_args: match args.lazy_function_args {
                        true => true,
                        false => defaults.lazy_function_args,
                    },
                    lazy_lambda_args: match args.lazy_lambda_args {
                        true => ArgType::Lazy,
                        false => defaults.lazy_lambda_args,
                    },
                    lazy_constructors: match args.lazy_constructors {
                        true => ArgType::Lazy,
                        false => defaults.lazy_constructors,
                    },
                    ..defaults
                }
            },
            runtime: {
                let defaults = WasmCompilerRuntimeOptions::default();
                WasmCompilerRuntimeOptions {
                    memoize_lambdas: args.memoize_lambdas,
                    ..defaults
                }
            },
            ..defaults
        }
    };
    let (wasm_module, entry_point_name) = match syntax {
        RuntimeEntryPointSyntax::Wasm => {
            let entry_point_name = args.entry_point.as_ref().cloned().unwrap_or_default();
            read_wasm_module(input_path)
                .map(WasmProgram::from_wasm)
                .map(|module| (module, entry_point_name))
        }
        RuntimeEntryPointSyntax::PrecompiledWasm => {
            let entry_point_name = args.entry_point.as_ref().cloned().unwrap_or_default();
            read_wasm_module(input_path)
                .map(WasmProgram::from_cwasm)
                .map(|module| (module, entry_point_name))
        }
        RuntimeEntryPointSyntax::Source(syntax) => {
            let entry_point_name = ModuleEntryPoint::default();
            let root = match syntax {
                Syntax::Lisp => {
                    CompilerRootConfig::Lisp(LispCompilerRootConfig::from(input_path.to_owned()))
                }
                Syntax::Json => {
                    CompilerRootConfig::Json(JsonCompilerRootConfig::from(input_path.to_owned()))
                }
                Syntax::JavaScript => CompilerRootConfig::JavaScript(
                    JavaScriptCompilerRootConfig::from(input_path.to_owned()),
                ),
            };
            let entry_point = GraphRootEntryPoint::new(entry_point_name.clone(), root);
            parse_and_compile_module(
                [&entry_point],
                default_js_loaders(empty(), &factory, &allocator),
                std::env::vars(),
                RUNTIME_BYTES,
                &factory,
                &allocator,
                &compiler_options,
                args.unoptimized,
            )
            .with_context(|| "Failed to compile entry point: {input_path}")
            .map(WasmProgram::from_wasm)
            .map(move |module| (module, entry_point_name))
        }
    }?;
    let mut logger = args.log.map(|format| match format {
        Some(LogFormat::Json) => {
            EitherLogger::Left(JsonActionLogger::<_, TAction, TTask>::stderr())
        }
        _ => EitherLogger::Right(FormattedActionLogger::<_, _, TAction, TTask>::stderr(
            TimestampedLogFormatter::rfc_3339(DefaultActionFormatter::new(factory.clone())),
        )),
    });
    if let Some(port) = args.metrics_port {
        let address = SocketAddr::from(([0, 0, 0, 0], port));
        log_server_action(
            &mut logger,
            &TAction::from(InitPrometheusMetricsAction { address }),
        );
        PrometheusBuilder::new()
            .with_http_listener(address)
            .install()
            .with_context(|| anyhow!("Failed to initialize Prometheus metrics endpoint"))?;
    }
    let https_client: hyper::Client<TConnect> = create_https_client(None)?;
    let grpc_services = load_grpc_services(args.grpc_service.iter())
        .with_context(|| "Failed to load gRPC service descriptor")?;
    let grpc_config = DefaultGrpcConfig::default();
    let grpc_max_operations_per_connection =
        match std::env::var("GRPC_MAX_OPERATIONS_PER_CONNECTION") {
            Ok(value) => str::parse::<usize>(&value)
                .with_context(|| "Invalid value for GRPC_MAX_OPERATIONS_PER_CONNECTION")
                .map(Some),
            _ => Ok(None),
        }?;
    let dump_heap_snapshot = args.dump_heap_snapshot;
    let schema = if let Some(schema_path) = &args.schema {
        Some(load_graphql_schema(schema_path.as_path())?)
    } else {
        None
    };
    let effect_throttle = args.effect_throttle_ms.map(Duration::from_millis);
    let mut logger = {
        let stdout_logger = logger;
        let prometheus_logger = args
            .metrics_port
            .map(|_| PrometheusLogger::<TAction, TTask>::new(Default::default()));
        ChainLogger::new(stdout_logger, prometheus_logger)
    };
    let tracer = match OpenTelemetryConfig::parse_env(std::env::vars())? {
        None => None,
        Some(config) => {
            log_server_action(
                &mut logger,
                &TAction::from(InitOpenTelemetryAction {
                    config: config.clone(),
                }),
            );
            Some(config.into_tracer()?)
        }
    };
    let (recorder, recorder_task) = args
        .capture_events
        .as_ref()
        .map(|output_path| {
            let output_format = match args.capture_type.as_ref() {
                None => FileWriterFormat::MessagePack,
                Some(EventCaptureType::Effect) => FileWriterFormat::Json,
            };
            let output_path = output_path
                .as_ref()
                .cloned()
                .unwrap_or_else(|| generate_session_recording_filename(output_format));
            log_server_action(
                &mut logger,
                &TAction::from(InitSessionRecordingAction {
                    output_path: output_path.clone(),
                }),
            );
            create_effect_recorder(args.capture_type, output_format, output_path)
        })
        .transpose()
        .map_err(|err| anyhow!("{}", err))
        .with_context(|| String::from("Unable to create session recording"))?
        .map(|(recorder, task)| (Some(recorder), task))
        .unwrap_or((None, None));
    let _recorder_handle = recorder_task.map(|task| tokio::runtime::Handle::current().spawn(task));
    let metric_names = ServerSchedulerMetricNames::default();
    let config: ReflexServerCliOptions = args.into();
    log_server_action(
        &mut logger,
        &TAction::from(InitHttpServerAction {
            address: config.address,
        }),
    );
    let server =
        cli::<TAction, TTask, T, TFactory, TAllocator, _, _, _, _, _, _, _, _, _, _, _, _, _, _>(
            config,
            wasm_module,
            entry_point_name,
            schema,
            GraphQlWebServerActorFactory::new(|context| {
                let reconnect_timeout = FibonacciReconnectTimeout {
                    units: Duration::from_secs(1),
                    max_timeout: Duration::from_secs(30),
                };
                default_handler_actors::<
                    TAction,
                    TTask,
                    T,
                    TFactory,
                    TAllocator,
                    TConnect,
                    TReconnect,
                >(
                    https_client,
                    &factory,
                    &allocator,
                    reconnect_timeout,
                    DefaultHandlerMetricNames::default(),
                    context.pid(),
                )
                .into_iter()
                .map(ServerCliTaskActor::Handler)
                .chain(once(ServerCliTaskActor::Grpc(GrpcHandler::new(
                    grpc_services,
                    WellKnownTypesTranscoder,
                    factory.clone(),
                    allocator.clone(),
                    reconnect_timeout,
                    grpc_max_operations_per_connection,
                    grpc_config,
                    GrpcHandlerMetricNames::default(),
                    context.pid(),
                ))))
                .map(|actor| (context.generate_pid(), actor))
                .collect::<Vec<_>>()
            }),
            &factory,
            &allocator,
            NoopGraphQlQueryTransform,
            NoopGraphQlQueryTransform,
            GraphQlWebServerMetricNames::default(),
            TokioRuntimeMonitorMetricNames::default(),
            GraphQlWebServerMetricLabels,
            GraphQlWebServerMetricLabels,
            GraphQlWebServerMetricLabels,
            GraphQlWebServerMetricLabels,
            GraphQlWebServerMetricLabels,
            match tracer {
                None => EitherTracer::Left(NoopTracer::default()),
                Some(tracer) => EitherTracer::Right(tracer),
            },
            ChainLogger::new(logger, recorder.map(SharedLogger::new)),
            ServerMetricsInstrumentation::new(
                NoopServerMetricsSchedulerQueueInstrumentation::default(),
                metric_names,
            ),
            TokioRuntimeThreadPoolFactory::new(tokio::runtime::Handle::current()),
            TokioRuntimeThreadPoolFactory::new(tokio::runtime::Handle::current()),
            effect_throttle,
            dump_heap_snapshot,
        )
        .with_context(|| anyhow!("Server startup failed"))?;
    server.await.with_context(|| anyhow!("Server error"))
}

fn create_effect_recorder<T: Expression, TAction, TTask>(
    capture_type: Option<EventCaptureType>,
    output_format: FileWriterFormat,
    output_path: impl AsRef<Path>,
) -> Result<
    (
        EitherLogger<
            SessionRecorder<AsyncChannelEventSink<TAction>, TAction, TTask>,
            EffectRecorder<
                T,
                SharedLogger<
                    EffectEventSerializerEventSink<
                        T,
                        AsyncChannelEventSink<SerializedEffectEvent<T>>,
                    >,
                >,
                TAction,
                TTask,
            >,
        >,
        Option<impl Future<Output = ()>>,
    ),
    String,
>
where
    T: Serialize + Send + 'static,
    T::Signal: Serialize + Send,
    TAction: Action + Clone + Serialize + Send + 'static,
    TAction: EvaluateHandlerAction<T>,
    TTask: TaskFactory<TAction, TTask>,
{
    match capture_type {
        None => {
            FileRecorder::<TAction>::create(output_format, output_path.as_ref()).map(|recorder| {
                let (sink, task) = AsyncChannelEventSink::create(recorder);
                let recorder = EitherLogger::Left(SessionRecorder::<_, TAction, TTask>::new(sink));
                let task = Some(task.left_future());
                (recorder, task)
            })
        }
        Some(EventCaptureType::Effect) => {
            FileRecorder::<SerializedEffectEvent<T>>::create(output_format, output_path.as_ref())
                .map(|recorder| {
                    let (sink, task) = AsyncChannelEventSink::create(recorder);
                    let recorder =
                        EitherLogger::Right(EffectRecorder::<T, _, TAction, TTask>::new(
                            SharedLogger::new(EffectEventSerializerEventSink::new(sink)),
                        ));
                    let task = Some(task.right_future());
                    (recorder, task)
                })
        }
    }
}

fn log_server_action<TAction: Action>(
    logger: &mut impl ActionLogger<Action = TAction>,
    action: &TAction,
) {
    logger.log(action)
}

fn load_graphql_schema(path: &Path) -> Result<GraphQlSchema> {
    let source = fs::read_to_string(path)
        .with_context(|| format!("Failed to load GraphQL schema: {}", path.to_string_lossy()))?;
    parse_graphql_schema(&source)
        .with_context(|| format!("Failed to load GraphQL schema: {}", path.to_string_lossy()))
}

fn read_wasm_module(path: &Path) -> Result<Vec<u8>> {
    std::fs::read(path).with_context(|| {
        format!(
            "Failed to load WebAssemby module: {}",
            path.to_string_lossy()
        )
    })
}
